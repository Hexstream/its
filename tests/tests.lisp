(cl:defpackage #:its_tests
  (:use #:cl #:parachute)
  (:import-from #:its #:its #:their))

(cl:in-package #:its_tests)

(defmacro are (comp expected form &optional description &rest format-args)
  `(is ,comp ,expected (multiple-value-list ,form) ,description ,@format-args))

(define-test "main"
  (are equal '(foo bar)
       (its (cons :car :cdr) (cons 'foo 'bar)))
  (are equal '(foo bar)
       (its (cons t) (cons 'foo 'bar)))
  (let ((displaced-to (make-array 9)))
    (are equal (list 8 displaced-to 1)
         (its (array length array-displacement)
           (make-array 8 :displaced-to displaced-to :displaced-index-offset 1))))
  (are equal '(my-foo my-bar no-baz)
       (its (hash-table (gethash 'foo) (gethash 'bar) (gethash 'baz 'no-baz))
         (let ((hash (make-hash-table :test 'eq)))
           (prog1 hash
             (setf (its (hash-table (gethash 'foo) (gethash 'bar))
                     hash)
                   (values 'my-foo 'my-bar))))))
  (are equal '(foo bar foo2 bar2)
       (let ((fun (its (cons t))))
         (multiple-value-call #'values
           (funcall fun '(foo . bar))
           (funcall fun '(foo2 . bar2)))))
  (defclass coords ()
    ((x :initarg :x)
     (y :initarg :y)
     (z :initarg :z)))
  (are equal '(0 1 t nil)
       (its (t (slot-value 'x 'y)
               (slot-exists-p 'z)
               (slot-boundp 'z))
         (make-instance 'coords :x 0 :y 1)))
  (are equal '(foo nil bar nil baz (quux))
       (their (cons :car :cdr) '(foo) '(bar) '(baz quux)))
  (are equal '(foo nil bar nil baz (quux))
       (let ((function (their (cons :car :cdr) (3))))
         (funcall function '(foo) '(bar) '(baz quux))))
  (are equal '(foo nil bar nil baz (quux))
       (let ((function (their (cons :car :cdr))))
         (funcall function '(foo) '(bar) '(baz quux))))
  (are equal '((cons1-new-car . cons1-new-cdr)
               (cons2-new-car . cons2-new-cdr))
       (let ((cons1 (cons 'cons1-car 'cons1-cdr))
             (cons2 (cons 'cons2-car 'cons2-cdr)))
         (setf (their (cons t) cons1 cons2)
               (values 'cons1-new-car 'cons1-new-cdr
                       'cons2-new-car 'cons2-new-cdr))
         (values cons1 cons2)))
  (are equal '(my-new-car my-new-cdr)
       (let ((my-cons (cons 'my-car 'my-cdr)))
         (setf (its (cons :car :cdr) my-cons)
               (values 'my-new-car 'my-new-cdr))
         (values (car my-cons) (cdr my-cons))))
  (are equal '(my-new-car my-new-cdr my-other-new-car my-other-new-cdr my-other-new-car my-other-new-cdr)
       (let ((my-cons (cons 'my-car 'my-cdr)))
         (multiple-value-call #'values
           (setf (its (values (cons t) (list t)) my-cons)
                 (values 'my-new-car 'my-new-cdr 'my-other-new-car 'my-other-new-cdr))
           (values (car my-cons) (cdr my-cons)))))
  (are equal '(new-car new-cdr new-car new-cdr new-cdr new-car new-car new-cdr)
       (let ((my-cons (cons nil nil)))
         (multiple-value-call #'values
           (setf (its cons my-cons) (values 'new-car 'new-cdr))
           (its cons my-cons)
           (its (cons :cdr :car t) my-cons))))
  (are equal (multiple-value-list (its (values (:lisp-implementation t) (:machine t)) t))
       (multiple-value-call #'values
         (its (:lisp-implementation t) t)
         (its (:machine t) t))))
